<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        
    </style>
</head>

<body>
    <script>
        /* function deleteRepeat(arr) {
            //第一层遍历，依次拿到每一个值  开始判断是否和后边的值有重复
            for (var i = 0; i < arr.length; i++) {
                //每次拿到数组的一个值之后，遍历后边的元素，判断是否有相等的
                for (var j = i + 1; j < arr.length; j++) {
                    //只要后边的值有和当前被检测的值相等，把这个重复的值删除掉
                    if (arr[i] === arr[j]) {
                        //删除重复的值
                        arr.splice(j, 1)
                        //只要使用原始的for循环，改变了原数组，则下标需要对应
                        //因为我们删除了数组的某个值，所以数组的下标依次前进一位，但是我们的j依然会累加，就会少检测一个值，所以需要j--
                        j--;
                    }
                }
            }
            //改变原数组 我们可以返回原数组的引用
            return arr;
        } */


        /* function deleteRepeat(arr) {
            var newArr = [];
            //第一层遍历，依次拿到每一个值  开始判断是否和后边的值有重复
            outer: for (var i = 0; i < arr.length; i++) {
                //每次拿到数组的一个值之后，遍历后边的元素，判断是否有相等的
                for (var j = i + 1; j < arr.length; j++) {
                    //只要后边的值有和当前被检测的值相等，则直接退出当前for  或者退出外层for执行下一次的外层for
                    if (arr[i] === arr[j]) {
                        // break;//退出当前内层for 但是外层for的当次内容执行完毕后，如果没有其他代码，直接可以执行下次的外层for
                        continue outer; //直接退出当次的外层for  执行下一次的外层for
                    }
                }
                //上边的内层for直到执行完成都没有退出，说明当前arr[i]后没有和它相等的元素了，我们可以取出来放到新数组中
                newArr.push(arr[i])
            }
            return newArr;
        } */



        // 新方法1
        /* function deleteRepeat(arr) {
            //遍历数组，判断当前的值的第一次出现的位置，是否是对应当前遍历的下标，如果是，则第一次出现，添加到新数组中，否则不是第一次出现，则忽略
            return arr.filter(function (item, index) {
                return index === arr.indexOf(item);
            })

        } */


        // 新方法2
        /* function deleteRepeat(arr) {
            const newArr = [];
            //遍历数组
            arr.forEach(function (item) {
                // 判断新数组中是否存在和item一样的值， 如果存在则不插入，如果不存在则插入
                if (newArr.indexOf(item) === -1) {
                    newArr.push(item);
                }
            })
            return newArr;
        } */


        // 新方法3
        function deleteRepeat(arr) {
            const newArr = [];
            return arr.reduce(function (acc, cur) {
                //判断acc中是否有cur
                if (acc.indexOf(cur) === -1) {
                    return acc.push(cur);
                    // return acc;
                }
                //如果acc中有cur 则什么都不做 直接把p返回 用来下一次判断
                return acc;
            }, [])
        }


























        // function deleteRepeat(arr) {
        //     // 通过indexOf查找第一个原理,如果查找当前循环的索引是否等于找到的元素所在的第一个索引，等于就返回，不等于就筛掉
        //     return arr.filter((item,index) => arr.indexOf(item) === index)
        // }


        // function deleteRepeat(arr) {
        //     // 通过indexOf查找第一个元素
        //     const newArr = []
        //     arr.forEach(item => {
        //         if(newArr.indexOf(item) === -1) newArr.push(item)
        //     })
        //     return newArr
        // }



        // function deleteRepeat(arr) {
        //     const newArr = []
        //     outer: for (let i = 0; i < arr.length; i++) {
        //         for (let j = i+1; j < arr.length; j++) {
        //             // 判断内层和外层循环是否相等，相等直接退出外层循环。将arr[i]添加到新数组
        //             if(arr[i] === arr[j]){
        //                 continue outer
        //             }
        //         }
        //         newArr.push(arr[i])
                
        //     }
        //     return newArr
        // }


        // function deleteRepeat(arr){
        //     for (let i = 0; i < arr.length; i++) {
        //         for (let j = i + 1; j < arr.length; j++) {  // 判断是否和第一遍循环的相等
        //             if(arr[i] === arr[j]){
        //                 arr.splice(j,1)
        //                 j--
        //             }
        //         }
        //     }
        //     return arr
        // }


        // function deleteRepeat(arr) {
        //     const newArr = [];
        //     return arr.reduce(function (acc, cur) {
        //         //判断p中是否有c
        //         if (acc.indexOf(acc) === -1) {
        //             acc.push(cur);
        //             return acc;
        //         }
        //         //如果p中有c 则什么都不做 直接把p返回 用来下一次判断
        //         return acc;
        //     }, [])
        // }





        const arr = [1,3,5,3,1,3,5,7,8]
        console.log(deleteRepeat(arr));
    </script>
</body>
</html>