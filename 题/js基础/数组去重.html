<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width= , initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /* 
          数组去重方法1：
            原始方法去重，返回去重后的数组 不能保证重后的顺序

         */
        /* function deleteRepeat(arr){
            var newArr = [];
            // 第一层遍历，依次拿到每一个值 开始判断是否和后边的值有重复
            outer:for(var i = 0; i < arr.length;j++){
                // 每次拿到数组的一个之后，遍历后边的元素，判断是否有相等的
                for(var  j = i + 1; j < arr.length;j++){
                    // 只要后边的值有和当前被检测的值相等，则直接退出当前for 或者退出外层for执行下一次的外层for
                    if(arr[i] === arr[j]){
                        // break;//退出当前内层for 但是外层for 的当次内容执行完毕后，如果没有其他代码，直接可以执行下次的外层for
                        continue outer; //直接退出当前次数的外层for 执行下一次的外层for
                    }
                }
                // 上边的内层for直接执行完成都没有退出，说明当前arr[i]后没有和它相等的元素了，我们可以取出来放到新数组中
                newArr.push(arr[i])
            }
            return newArr;
        }
 */     
        /* 
        数组去重方法2：
            原始遍历方法，检测每个值，如果后边有相同的，就直接删除，修改了原数组
         */
        /*  function delteteRepeat(arr){
            //  第一层遍历 依次拿到每一个值 开始判断是否和后边的值有重复
             for(var i = 0;i < arr.length;i++){
                //  每次拿到数组的一个之后 遍历后边的元素，判断是否有相等的
                 for (var j = i + 1;j < arr.length;j++){
                    //  只要后边的值有和当前被检测的值相等，把这个重复的值删除掉
                     if(arr[i]=== arr[j]){
                        //  删除重复的值
                         arr.splice(j,1);
                        //  只要使用原始的for循环，改变了原数组，则下标需要对应
                        // 因为我们删除了数组的某个值，所以数组的下标依次前进一位，但我们的j依然会累加，就会少检测一个值，所以需要j--
                         j--;
                     }
                 }
             }
            //  改变原数组 我们可以返回原数组的引用
            return arr;
         } */

         /* 
            数组去重方法三：
         */
       /*  function deleteRepeat(arr){
            var newArr = [];
            // 遍历数组，判断当前的值的一个出现的位置 是否是对应当前遍历得下标，如果是，则第一次出现，添加到新数组中，否则不是第一次出现，则忽略
            arr.forEach(function (item,index){
                if(index === arr.indexof(item)){
                    newArr.push(item);
                }
            })
            return newArr;
        } */


        /* function delteteRepeat(arr){
            // 遍历数组，判断当前的值的第一次出现的位置，是否是对应当前遍历得下标，如果是，这第一次出现，添加到新数组中，否则不是第一次出现，则忽略
            return arr.filter(function(item,index){
                return index === arr.indexOf(item);
            })
        } */

        /* 
            数组去重方法1：
                把每一个值一次插入到新数组中，插入之前判断新数组是否存在这个值，如果有，则不插入
        */

       /*  function delteteRepeat(arr){
            var newArr = [];
            // 遍历数组
            arr.forEach(function(item){
                // 判断新数组中是否存在和item一样的值，如果存在则不插入，如果不存在则插入
                if(newArr.indexOf(item) === -1){
                    newArr.push(item)
                }
            })
            return newArr;
        } */

        function delteteRepeat(arr){
            var newArr = [];
            return arr.reduce(function(p,c){
                // 判断p中是否有c
                if(p.indexOf(c) === -1){
                    p.push(c);
                    return p;
                }
                // 如果p中有c 则什么都不做 直接把p返回 用来下一次判断
                return p;
            },[])
        }
         var myArr = [4, 3, 6, 4, 1, 6, 2, 9, 3, 7, 9, 6]
         var re = delteteRepeat(myArr);
         console.log(re,myArr);
    </script>
</body>
</html>